import math
from collections import deque
import heapq

# Define the goal state for easy comparison
goal_state = [0, 1, 2, 3, 4, 5, 6, 7, 8]

# Function to print the puzzle board in a 3x3 format
def print_board(state):
    print("\n".join([" ".join(map(str, state[i:i+3])) for i in range(0, 9, 3)]))
    print("")

# Function to get neighbors by moving the empty space (0) in 4 possible directions
def get_neighbors(state):
    neighbors = []
    zero_index = state.index(0)
    row, col = zero_index // 3, zero_index % 3

    moves = {
        "Up": (row - 1, col),
        "Down": (row + 1, col),
        "Left": (row, col - 1),
        "Right": (row, col + 1)
    }

    for direction, (new_row, new_col) in moves.items():
        if 0 <= new_row < 3 and 0 <= new_col < 3:
            new_zero_index = new_row * 3 + new_col
            new_state = state[:]
            new_state[zero_index], new_state[new_zero_index] = new_state[new_zero_index], new_state[zero_index]
            neighbors.append(new_state)
    
    return neighbors

# BFS implementation
def bfs_search(initial_state):
    frontier = deque([(initial_state, [])])
    explored = set()

    while frontier:
        state, path = frontier.popleft()

        if state == goal_state:
            return path + [state]
        
        explored.add(tuple(state))
        
        for neighbor in get_neighbors(state):
            if tuple(neighbor) not in explored and neighbor not in frontier:
                frontier.append((neighbor, path + [state]))
    
    return None

# DFS implementation
def dfs_search(initial_state):
    frontier = [(initial_state, [])]
    explored = set()

    while frontier:
        state, path = frontier.pop()

        if state == goal_state:
            return path + [state]
        
        explored.add(tuple(state))
        
        for neighbor in get_neighbors(state):
            if tuple(neighbor) not in explored and neighbor not in frontier:
                frontier.append((neighbor, path + [state]))
    
    return None

# Heuristic functions
def manhattan_distance(state):
    distance = 0
    for i in range(1, 9):
        current_index = state.index(i)
        goal_index = goal_state.index(i)
        current_row, current_col = current_index // 3, current_index % 3
        goal_row, goal_col = goal_index // 3, goal_index % 3
        distance += abs(current_row - goal_row) + abs(current_col - goal_col)
    return distance

def euclidean_distance(state):
    distance = 0
    for i in range(1, 9):
        current_index = state.index(i)
        goal_index = goal_state.index(i)
        current_row, current_col = current_index // 3, current_index % 3
        goal_row, goal_col = goal_index // 3, goal_index % 3
        distance += math.sqrt((current_row - goal_row)**2 + (current_col - goal_col)**2)
    return distance

# A* Search implementation
def a_star_search(initial_state, heuristic):
    frontier = []
    heapq.heappush(frontier, (0, initial_state, []))
    explored = set()
    cost_so_far = {tuple(initial_state): 0}

    while frontier:
        _, state, path = heapq.heappop(frontier)

        if state == goal_state:
            return path + [state]
        
        explored.add(tuple(state))

        for neighbor in get_neighbors(state):
            new_cost = cost_so_far[tuple(state)] + 1
            if tuple(neighbor) not in cost_so_far or new_cost < cost_so_far[tuple(neighbor)]:
                cost_so_far[tuple(neighbor)] = new_cost
                priority = new_cost + heuristic(neighbor)
                heapq.heappush(frontier, (priority, neighbor, path + [state]))
    
    return None

# Function to visualize the output path
def print_solution_path(path):
    for step, state in enumerate(path):
        print(f"Step {step}:")
        print_board(state)

# Run the search algorithms and print their outputs
initial_state = [1, 2, 5, 3, 4, 0, 6, 7, 8]

print("BFS Solution:")
bfs_path = bfs_search(initial_state)
print_solution_path(bfs_path)

print("DFS Solution:")
dfs_path = dfs_search(initial_state)
print_solution_path(dfs_path)

print("A* Solution with Manhattan Distance:")
a_star_path_manhattan = a_star_search(initial_state, manhattan_distance)
print_solution_path(a_star_path_manhattan)

print("A* Solution with Euclidean Distance:")
a_star_path_euclidean = a_star_search(initial_state, euclidean_distance)
print_solution_path(a_star_path_euclidean)

# Compare the number of nodes expanded for Manhattan vs. Euclidean
print("Comparison:")
print(f"Nodes expanded for A* with Manhattan Distance: {len(a_star_path_manhattan) - 1}")
print(f"Nodes expanded for A* with Euclidean Distance: {len(a_star_path_euclidean) - 1}")
# Function to print the goal state in a 3x3 format
def print_goal_state():
    print_board(goal_state)

# Call this function where you want to display the goal state
print("Goal State:")
print_goal_state()


